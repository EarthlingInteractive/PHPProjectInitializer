## EIT PHP Project Initializer

This project contains templates and a script to initialize files for a
new PHP project following the following conventions.  To start a new
project with it, create and cd into a new directory and run
```create-project.php -i``` (you can run it from anywhere; it will
find the templates relative to whatever path you give to
```create-project.php```).  It will prompt you for a project name
(type it like you would in your native language, e.g. "Bob's Cool
Thinger") and a namespace with which to prefix all your
project-specific classes (e.g. "Bob_CoolThinger"), and then create a
bunch of files to get you started.

### Deployment structure

Composer is used for dependency management.

Projects should be and/or use Composer-compatible packages.

The root folder of a project should contain:

```
  www/            ; Files and scripts used by Apache
    bootstrap.php ; All requests to non-static files go through here
    .htaccess     ; Tells Apache to rewrite requests to bootstrap.php/$1

  config/         ; Application configuration
    dbc.json      ; Database connection configuration
    auth.json     ; Security configuration
    ...etc...     ; More config files as needed by your project.
  
  composer.json   ; Tells Composer about dependencies
  schema.txt      ; Describes the data classes
  Makefile (or equivalent)
  util/           ; Utility programs used by build scripts
  build/          ; Scripts and other files used for offline initialization of the project
    db/           ; Database-related
      upgrades/   ; Database upgrade scripts
      procedures/ ; Scripts to initialize procedures (run after every update)
      triggers/   ; Scripts to initialize triggers (run after every update)
  lib/            ; PHP classes not managed by Composer go in here
  vendor/         ; Composer sticks dependencies in here.  Should be .gitignored.
```

Any other static files (images, CSS, JavaScript) go in ```www/```.
For example, javascript might get compiled to ```www/js/cool-app.js```.

Files that are generated by some build process should _not_ be checked
in on development branches (especially 'master' or 'trunk' or
equivalent), though we may choose to create 'prebuilt' branches on
which we do check in generated files before deploying to
staging/productions.

Generated files and checked-in files may be intermingled throughout
various directories, but generated files should be .gitignored and
mentioned as targets in the Makefile.

The Makefile should have 'clean' and 'all' targets that
remove and build everything the project needs to run, respectively.

Config files are JSON instead of PHP so that non-PHP utilities can read them.

Config JSON files should not be checked into the repository, but
example config files (with a .example extension) may be to give
hints to people who check out the project.

I don't really like that the directory where Composer sticks all its dependencies
is called 'vendor' because it doesn't indicate the purpose of that directory
(something like "composer-managed-php-libraries" would be better), but AFAIK
there's any way to configure that, so we just have to remember that 'vendor'
means 'directory containing Composer-managed PHP libraries', similar to how
we need to remember that ```package.json``` is the file defining our Node.js
dependencies despite its generic name.

### PHP Code Structure

All PHP code except for bootstrapping code, view templates, and a few utility
functions (coalesce, ezdie) should be in classes.

All classes should be namespaced.  e.g. "CoolNewProject_Registry".

I prefer underscores to the backslash-delimited namespace style
intruduced by PHP 5.3 because it makes it easier to tell at a glance
exactly what classes are being referenced.  Projects created with this
setter-upper include a class loader that will alias between
```SomePackage_SomeClass``` and ```SomePackage\SomeClass``` as
needed.

#### Configuration

Projects should define a root ```<ProjectName>_Registry``` class which is initialized by
bootstrap.php and is reponsible for giving access to all things that can be
affected by configuration:

- Config variables
- View templates
- Components (a.k.a. 'models')
  - The request dispatcher
  - Database accessor(s)
  - Emailers
  - etc

#### Serving web pages

- HTTP responses are represented as Nife_HTTP_Response objects and are
  returned by the dispatcher and, presumably, whatever components
  it delegates to.  bootstrap.php does the actual outputting of them.
- Requests are not generally encapsulated, though paths are usually
  passed around explicitly.  When access to request data is needed,
  just use ```$_GET```, ```$_SERVER```, ```$_SESSION```, etc. directly.

#### Database access

- Doctrine's database API seems legit, so we're going with that for now.
- Support for multiple result sets would be nice but most high-level
  PHP database query APIs don't provide any way to do it.
- Something that lets one include arrays and complex SQL expressions that
  themselves include parameters (like our First30 datbase accessor class)
  would be nice.

The best thing to do might be to write our own database API
and write an implementation that wraps Doctrine's.  Or some other one.
If we're writing our own wrapper anyway then then the backend can be switched out.

#### ORMs and stuff

I haven't chosen an ORM because it's not obvious that we need one.

Schema.txt can describe all tables and their metadata,
and from this, services or configuration files for some ORM (if/when
we do choose to use one) can be automatically generated.

#### Objects

Data objects are dumb; possibly just arrays of field name => value.

Storage, retrieval, and validation is not done by the objects themselves
but by accessor components.

#### Components?

Components are heavy objects that generally have only one instance per
class and live the entire life of the program.  They can be thought of
as being relatively static.  Caches, loggers, and persistent database
connections are examples of 'component' objects.

If data objects are water, components are your water heater, faucet,
and toilet.  And maybe your freezer, if you have one of those
automatic ice makers.

#### E-mailing

Swiftmailer seems dece.

### Database

Use Postgres.
